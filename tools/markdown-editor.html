<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Markdown åœ¨çº¿ç¼–è¾‘å™¨ Â· å·¥å…·ç®±</title>
  <link rel="stylesheet" href="../assets/css/style.css">
  <link rel="stylesheet" href="../assets/css/markdown-editor.css">
  <meta name="color-scheme" content="light dark">
</head>
<body>
  <header class="site-header">
    <div class="container">
      <h1 class="site-title">ğŸ“ Markdown åœ¨çº¿ç¼–è¾‘å™¨</h1>
      <p class="site-subtitle">å·¦ä¾§ç¼–è¾‘ï¼Œå³ä¾§é¢„è§ˆï¼Œæ”¯æŒä¸€é”®å¯¼å‡º PDF</p>
    </div>
  </header>

  <main class="container">
    <div class="editor-container">
      <!-- å·¥å…·æ  -->
      <div class="toolbar">
        <div class="toolbar-left">
          <button class="tool-btn" onclick="insertText('**', '**')" title="ç²—ä½“">
            <strong>B</strong>
          </button>
          <button class="tool-btn" onclick="insertText('*', '*')" title="æ–œä½“">
            <em>I</em>
          </button>
          <button class="tool-btn" onclick="insertText('~~', '~~')" title="åˆ é™¤çº¿">
            <del>S</del>
          </button>
          <button class="tool-btn" onclick="insertText('`', '`')" title="è¡Œå†…ä»£ç ">
            <code>{}</code>
          </button>
          <button class="tool-btn" onclick="insertText('```\n', '\n```')" title="ä»£ç å—">
            <code>```</code>
          </button>
          <button class="tool-btn" onclick="insertText('- ', '')" title="æ— åºåˆ—è¡¨">
            â€¢
          </button>
          <button class="tool-btn" onclick="insertText('1. ', '')" title="æœ‰åºåˆ—è¡¨">
            1.
          </button>
          <button class="tool-btn" onclick="insertText('> ', '')" title="å¼•ç”¨">
            "
          </button>
          <button class="tool-btn" onclick="insertText('# ', '')" title="æ ‡é¢˜">
            H
          </button>
          <button class="tool-btn" onclick="insertText('[', '](url)')" title="é“¾æ¥">
            ğŸ”—
          </button>
          <button class="tool-btn" onclick="insertText('![', '](image-url)')" title="å›¾ç‰‡">
            ğŸ–¼ï¸
          </button>
        </div>
        <div class="toolbar-right">
          <button class="tool-btn primary" onclick="exportPDF()" title="å¯¼å‡º PDF">
            ğŸ“„ PDF
          </button>
          <button class="tool-btn" onclick="downloadMarkdown()" title="ä¸‹è½½ Markdown">
            ğŸ’¾ MD
          </button>
          <button class="tool-btn" onclick="clearEditor()" title="æ¸…ç©ºç¼–è¾‘å™¨">
            ğŸ—‘ï¸ æ¸…ç©º
          </button>
        </div>
      </div>

      <!-- ç¼–è¾‘å™¨ä¸»ä½“ -->
      <div class="editor-main">
        <!-- å·¦ä¾§ç¼–è¾‘åŒºåŸŸ -->
        <div class="editor-panel">
          <div class="panel-header">
            <h3>ğŸ“ ç¼–è¾‘åŒºåŸŸ</h3>
            <span class="char-count" id="charCount">0 å­—ç¬¦</span>
          </div>
          <textarea 
            id="markdownEditor" 
            class="markdown-input" 
            placeholder="åœ¨è¿™é‡Œè¾“å…¥ Markdown å†…å®¹...

# æ¬¢è¿ä½¿ç”¨ Markdown ç¼–è¾‘å™¨

## åŠŸèƒ½ç‰¹æ€§
- âœ¨ å®æ—¶é¢„è§ˆ
- ğŸ“„ PDF å¯¼å‡º
- ğŸ’¾ æœ¬åœ°ä¿å­˜
- ğŸŒ™ æš—è‰²ä¸»é¢˜

## ä½¿ç”¨è¯´æ˜
1. å·¦ä¾§è¾“å…¥ Markdown è¯­æ³•
2. å³ä¾§å®æ—¶æŸ¥çœ‹æ•ˆæœ
3. ç‚¹å‡»å·¥å…·æ æŒ‰é’®å¿«é€Ÿæ’å…¥æ ¼å¼
4. æ”¯æŒå¯¼å‡º PDF å’Œä¸‹è½½ Markdown æ–‡ä»¶

## å¿«æ·é”®
- `Ctrl + S`: ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
- `Ctrl + Z`: æ’¤é”€
- `Ctrl + Y`: é‡åš

å¼€å§‹ç¼–å†™ä½ çš„æ–‡æ¡£å§ï¼"
          ></textarea>
        </div>

        <!-- å³ä¾§é¢„è§ˆåŒºåŸŸ -->
        <div class="preview-panel">
          <div class="panel-header">
            <h3>ğŸ‘ï¸ é¢„è§ˆæ•ˆæœ</h3>
            <div class="preview-controls">
              <button class="tool-btn small" onclick="togglePreview()" id="togglePreviewBtn">
                ğŸ‘ï¸ éšè—
              </button>
            </div>
          </div>
          <div id="previewContent" class="markdown-preview"></div>
        </div>
      </div>
    </div>

    <!-- è¿”å›é¦–é¡µ -->
    <div class="back-home">
      <a href="../index.html" class="back-link">â† è¿”å›å·¥å…·ç®±é¦–é¡µ</a>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container">
      <span>Â© <span id="year"></span> å·¥å…·ç®±</span>
    </div>
  </footer>

  <!-- å¼•å…¥ Markdown è§£æåº“ -->
  <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
  <!-- å¼•å…¥ä»£ç é«˜äº®åº“ -->
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <!-- å¼•å…¥ PDF å¯¼å‡ºåº“ -->
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>

  <script>
    // å…¨å±€å˜é‡
    let editor = null;
    let previewVisible = true;
    let autoSaveTimer = null;

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
      initializeEditor();
      loadFromLocalStorage();
      setupEventListeners();
      updateYear();
    });

    // åˆå§‹åŒ–ç¼–è¾‘å™¨
    function initializeEditor() {
      editor = document.getElementById('markdownEditor');
      
      // é…ç½® Marked é€‰é¡¹
      marked.setOptions({
        breaks: true,
        gfm: true,
        headerIds: true,
        mangle: false
      });

      // è‡ªå®šä¹‰æ¸²æŸ“å™¨
      const renderer = new marked.Renderer();
      renderer.code = function(code, language) {
        const validLanguage = Prism.languages[language] ? language : 'markup';
        const highlighted = Prism.highlight(code, Prism.languages[validLanguage], validLanguage);
        return `<pre class="language-${validLanguage}"><code class="language-${validLanguage}">${highlighted}</code></pre>`;
      };
      marked.use({ renderer });
    }

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    function setupEventListeners() {
      editor.addEventListener('input', function() {
        updatePreview();
        updateCharCount();
        autoSave();
      });

      // å¿«æ·é”®æ”¯æŒ
      editor.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key) {
            case 's':
              e.preventDefault();
              saveToLocalStorage();
              showToast('å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
              break;
            case 'z':
              if (e.shiftKey) {
                e.preventDefault();
                document.execCommand('redo');
              } else {
                e.preventDefault();
                document.execCommand('undo');
              }
              break;
          }
        }
      });
    }

    // æ›´æ–°é¢„è§ˆ
    function updatePreview() {
      const markdown = editor.value;
      const preview = document.getElementById('previewContent');
      
      try {
        const html = marked.parse(markdown);
        preview.innerHTML = html;
        
        // é‡æ–°åº”ç”¨ä»£ç é«˜äº®
        if (window.Prism) {
          Prism.highlightAllUnder(preview);
        }
      } catch (error) {
        preview.innerHTML = `<div class="error">è§£æé”™è¯¯: ${error.message}</div>`;
      }
    }

    // æ›´æ–°å­—ç¬¦è®¡æ•°
    function updateCharCount() {
      const count = editor.value.length;
      const charCount = document.getElementById('charCount');
      charCount.textContent = `${count} å­—ç¬¦`;
    }

    // æ’å…¥æ–‡æœ¬
    function insertText(before, after) {
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      const text = editor.value;
      const selectedText = text.substring(start, end);
      
      const newText = before + selectedText + after;
      editor.value = text.substring(0, start) + newText + text.substring(end);
      
      // è®¾ç½®å…‰æ ‡ä½ç½®
      if (selectedText.length === 0) {
        editor.selectionStart = editor.selectionEnd = start + before.length;
      } else {
        editor.selectionStart = start;
        editor.selectionEnd = start + newText.length;
      }
      
      editor.focus();
      updatePreview();
      updateCharCount();
    }

    // åˆ‡æ¢é¢„è§ˆ
    function togglePreview() {
      const previewPanel = document.querySelector('.preview-panel');
      const toggleBtn = document.getElementById('togglePreviewBtn');
      
      if (previewVisible) {
        previewPanel.style.display = 'none';
        toggleBtn.textContent = 'ğŸ‘ï¸ æ˜¾ç¤º';
        document.querySelector('.editor-main').style.gridTemplateColumns = '1fr';
      } else {
        previewPanel.style.display = 'block';
        toggleBtn.textContent = 'ğŸ‘ï¸ éšè—';
        document.querySelector('.editor-main').style.gridTemplateColumns = '1fr 1fr';
      }
      
      previewVisible = !previewVisible;
    }

    // å¯¼å‡º PDF
    function exportPDF() {
      const markdown = editor.value;
      if (!markdown.trim()) {
        showToast('è¯·å…ˆè¾“å…¥ä¸€äº›å†…å®¹');
        return;
      }

      const preview = document.getElementById('previewContent');
      const originalDisplay = preview.style.display;
      
      // ä¸´æ—¶æ˜¾ç¤ºé¢„è§ˆå†…å®¹
      preview.style.display = 'block';
      
      const opt = {
        margin: [10, 10, 10, 10],
        filename: 'markdown-document.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };

      html2pdf().set(opt).from(preview).save().then(() => {
        preview.style.display = originalDisplay;
        showToast('PDF å¯¼å‡ºæˆåŠŸï¼');
      }).catch(error => {
        preview.style.display = originalDisplay;
        showToast('PDF å¯¼å‡ºå¤±è´¥: ' + error.message);
        console.error('PDF export error:', error);
      });
    }

    // ä¸‹è½½ Markdown
    function downloadMarkdown() {
      const markdown = editor.value;
      if (!markdown.trim()) {
        showToast('è¯·å…ˆè¾“å…¥ä¸€äº›å†…å®¹');
        return;
      }

      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'document.md';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast('Markdown æ–‡ä»¶ä¸‹è½½æˆåŠŸï¼');
    }

    // æ¸…ç©ºç¼–è¾‘å™¨
    function clearEditor() {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†…å®¹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
        editor.value = '';
        updatePreview();
        updateCharCount();
        localStorage.removeItem('markdownEditor_content');
        showToast('ç¼–è¾‘å™¨å·²æ¸…ç©º');
      }
    }

    // è‡ªåŠ¨ä¿å­˜
    function autoSave() {
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
      }
      
      autoSaveTimer = setTimeout(() => {
        saveToLocalStorage();
      }, 1000);
    }

    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    function saveToLocalStorage() {
      try {
        localStorage.setItem('markdownEditor_content', editor.value);
        localStorage.setItem('markdownEditor_timestamp', Date.now());
      } catch (error) {
        console.error('ä¿å­˜å¤±è´¥:', error);
      }
    }

    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
    function loadFromLocalStorage() {
      try {
        const saved = localStorage.getItem('markdownEditor_content');
        const timestamp = localStorage.getItem('markdownEditor_timestamp');
        
        if (saved && timestamp) {
          const age = Date.now() - parseInt(timestamp);
          const maxAge = 7 * 24 * 60 * 60 * 1000; // 7å¤©
          
          if (age < maxAge) {
            editor.value = saved;
            updatePreview();
            updateCharCount();
            showToast('å·²æ¢å¤ä¸Šæ¬¡ç¼–è¾‘çš„å†…å®¹');
          } else {
            localStorage.removeItem('markdownEditor_content');
            localStorage.removeItem('markdownEditor_timestamp');
          }
        }
      } catch (error) {
        console.error('åŠ è½½å¤±è´¥:', error);
      }
    }

    // æ˜¾ç¤ºæç¤º
    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // æ›´æ–°å¹´ä»½
    function updateYear() {
      document.getElementById('year').textContent = new Date().getFullYear();
    }
  </script>
</body>
</html>